#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Conway's game of life@author: jack hester"""import numpy as npfrom PIL import Imageimport os# find count of populated (alive) moore neighbors# param i and param j the index of the 2D array to get neighbor count for# param grid_dim the side-dimension of your square grid# param grid the current status of the grid (2D array)# return count, the number of alive moore neighbors next to that celldef moore_count(i,j, grid_dim, grid):    count = 0    dx, dy = 1, 1    # up and down    if (i+dx < grid_dim and i+dx >=0) and grid[(i+dx),j] != 0:        count+=1    if (i-dx < grid_dim and i-dx >=0) and grid[(i-dx),j] != 0:        count+=1    # left and right    if (j-dx < grid_dim and j-dx >=0) and grid[i,(j-dx)] != 0:        count+=1    if (j+dy < grid_dim and j+dy >=0 ) and grid[i,(j+dy)] != 0:        count+=1    #diagonals    if (i-dx < grid_dim and i-dx >=0) and (j-dx < grid_dim and j-dx>=0) and grid[(i-dx),(j-dx)] != 0:        count+=1    if (i-dx < grid_dim and i-dx >=0) and (j+dx < grid_dim and j+dx >=0) and grid[(i-dx),(j+dx)] != 0:        count+=1    if (i+dx < grid_dim and i+dx >=0) and (j-dx < grid_dim and j-dx >=0) and grid[(i+dx),(j-dx)] != 0:        count +=1    if (i+dx < grid_dim and i+dx >=0) and (j+dx < grid_dim and j+dx >=0) and grid[(i+dx),(j+dx)] != 0:        count +=1    return count# run the actual game# param grid_dim the dimension of the (square) grid to create# param num_time_steps how many timesteps to run game over# param choice_array an array containing zeroes and 255 depending on probability of being alive# 0 represents dead 255 represents alive (0 required, 255 can be another color/int)# saves images as game_<timestep>.pngdef game(grid_dim, num_time_steps, choice_array):    #initialize the game    #print(choices)    grid = np.zeros((grid_dim,grid_dim),dtype=np.uint8)    for i in range(0, grid_dim):        for j in range(0, grid_dim):            grid[i,j] = np.random.choice(choice_array)    img = Image.fromarray(grid)    savename = "game_0.png"    img.save(os.path.join("images",savename))    t = 1    while t < num_time_steps:        #new_grid = grid        # play a time step        for i in range(0, grid_dim):            for j in range(0, grid_dim):                neighbors = moore_count(i,j, grid_dim, grid)                #neighbors = moore_count(i,j, grid_dim, grid)                # Any live cell with fewer than two live neighbours dies, as if by underpopulation.                if grid[i,j] !=0 and neighbors <2:                    grid[i,j] = 0                #neighbors = moore_count(i,j, grid_dim, grid)                # Any live cell with two or three live neighbours lives on to the next generation.                # no code needed)                # Any live cell with more than three live neighbours dies, as if by overpopulation.                if grid[i,j] != 0 and neighbors > 3:                    grid[i,j] = 0                # Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.                if grid[i,j] == 0 and neighbors == 3:                    grid[i,j] = 255        #grid = new_grid        img = Image.fromarray(grid)        savename = "game_" + str(t) +".png"        img.save(os.path.join("images",savename))        t += 1# set probability of being alive at init, call the gamedef main(grid_dim, num_time_steps):    # initialize with 1/10 chance of being alive    choices = np.zeros(20)    choices[19] = 255    game(grid_dim,num_time_steps,choices)